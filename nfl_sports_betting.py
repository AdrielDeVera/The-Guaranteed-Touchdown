# -*- coding: utf-8 -*-
"""NFL Sports Betting

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HZeN2ohKqxfWDdUTgVN3ZsyP4dRpixeS

# NFL Game Score Prediction
We will be using historical NFL game data to predict team performance with consideration to other independent variables such as stadium, weather, and media odds. 

A model that predicts the score of each team based on variables such as home-team status, weather, and historical performance is leveraged to generate predicted scores. To boost the currency of the data used, only the previous seasons since 2000 will be used.
"""

# Commented out IPython magic to ensure Python compatibility.
# Importing libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

stadiums = pd.read_csv('./data/nfl_stadiums.csv', encoding='latin1')
teams = pd.read_csv('./data/nfl_teams.csv', encoding='latin1')
games = pd.read_csv('./data/spreadspoke_scores.csv',encoding='latin1')

stadiums.head(2)

# Dropping unnecessary features
stadiums.drop(columns=['stadium_address', 'stadium_weather_station_code' ,'STATION',	'NAME',	'LATITUDE',	'LONGITUDE', 'ELEVATION'], inplace=True)

# Converting dtype to datetime
games['schedule_date'] = pd.to_datetime(games['schedule_date'])

# Removing entries that fall prior to 2000.
mask = (games['schedule_date'] > '2000-1-1')
games = games.loc[mask]
games = games[games['schedule_season'] != 1999]
games['schedule_season'].value_counts()

# Dropping extra unnecessary column
games.drop(columns=['over_under_line'], inplace=True)

# Converting datatypes to 0,1 binary codes
games["schedule_playoff"] = games["schedule_playoff"].astype(int)
games['stadium_neutral'] = games['stadium_neutral'].astype(int)
games[['schedule_playoff', 'stadium_neutral']].head(2)

# Confirming 36 teams in NFL
games['team_home'].nunique(), games['team_away'].nunique()

# Connecting Team ID to Team Name and correcting Dict values for some teams
team_id = dict(zip(teams.team_id, teams.team_name))
team_id['ARI'] = 'Arizona Cardinals'
team_id['LAC'] = 'Los Angeles Chargers'
team_id['LAR'] = 'St. Louis Rams'
team_id['LVR'] = 'Las Vegas Raiders'
team_id['NE'] = 'New England Patriots'
team_id

# Changing Team ID's to Team Names
games.replace({"team_favorite_id": team_id}, inplace=True)
games['team_favorite_id'].value_counts(), games['team_favorite_id'].nunique()
games = games[games['team_favorite_id'] != 'PICK']
games.tail()

# Creating home win column and representing favorite team as binary classifier depending if favorite team is home team or not
games['home_win'] = games['score_home'] > games['score_away']
games['home_win'] = games['home_win'].astype(int)
games['team_favorite_id'] = games['team_favorite_id'] == games['team_home']
games['team_favorite_id'] = games['team_favorite_id'].replace({True: 1, False: 0, np.nan:'nan'})
games['team_favorite_id'].replace({'nan':np.nan}, inplace=True)
games['team_favorite_id'].value_counts()

# Resetting index
games.reset_index(drop=True, inplace=True)

# Merging the data for stadiums to the games df
games = pd.merge(games, stadiums, left_on = 'stadium', right_on = 'stadium_name')

# Resorting to be by date
games.sort_values('schedule_date', inplace = True)

# For MVP, decided weather features for model are to be dropped.
games.drop(columns=['stadium_weather_type', 'weather_wind_mph', 'weather_humidity', 'weather_detail', 'weather_temperature', 'stadium_open', 'stadium_location', 'stadium_close'], inplace=True)

games = games.dropna(subset=['score_home', 'score_away'])









def calculate_winner(home_team, away_team):
  teams = [home_team, away_team]
  sample = games.loc[games['team_home'].isin(teams) & games['team_away'].isin(teams)]
  wins, total, wins1, total1, wins2, total2, wins3, total3 = 0, 0, 0, 0, 0, 0, 0, 0
  sample1 = sample.query('team_home == @teams[0]')

  for index, row in sample.iterrows():
      if row['score_home'] > row['score_away']:
        wins += 1
      total += 1
  h2h = round(wins/total, 2)

  for index, row in sample1.iterrows():
      if row['score_home'] > row['score_away']:
        wins1 += 1
      total1 += 1
  home = round(wins1/total1, 2)

  sample2 = games.query('team_home == @teams[0] or team_away == @teams[0]')
  for index, row in sample2.iterrows():
      if row['score_home'] == teams[0]:
        if row['score_home'] > row['score_away']:
                wins2 += 1
      else:
        if row['score_home'] < row['score_away']:
                wins2 += 1
      total2 += 1
  val1 = round(wins2/total2, 2)

  sample2 = games.query('team_home == @teams[1] or team_away == @teams[1]')
  for index, row in sample2.iterrows():
      if row['score_home'] == teams[1]:
        if row['score_home'] > row['score_away']:
                wins2 += 1
      else:
        if row['score_home'] < row['score_away']:
                wins2 += 1
      total2 += 1
  val2 = round(wins2/total2, 2)

  sample3 = games.query('team_home == @teams[0]')
  for index, row in sample3.iterrows():
      if row['score_home'] > row['score_away']:
        wins3 += 1
      total3 += 1
  home_r = round(wins3/total3, 2)

  fav1 = games.query('team_home == @teams[0]')['team_favorite_id'].mean()
  fav2 = games.query('team_home == @teams[1]')['team_favorite_id'].mean()

  ave = (h2h + home + home_r)/3
  if val1 > val2:
    ave += 0.02
  elif val1 < val2:
    ave-= 0.02

  if fav1 > fav2:
    ave += 0.02
  elif fav1 < fav2:
    ave-= 0.02

  if ave > 0.5:
    print(f"The favorite is: {teams[0]}")
    return teams[0]
  else:
    print(f"The favorite is: {teams[1]}")
    return teams[1]








# import datetime
# from sklearn.linear_model import LinearRegression
# from sklearn.model_selection import train_test_split

# games['schedule_date'] = games['schedule_date'].map(datetime.datetime.toordinal)

# y = np.asarray(games['score_home'])
# X = games[['schedule_date']]
# X_train, X_test, y_train, y_test = train_test_split(X,y,train_size=0.7,random_state=42)

# model = LinearRegression() 
# model.fit(X_train, y_train) 
# # results = model.predict(X_test)
# # X_test = X_test['schedule_date'].astype(int).map(dt.datetime.fromordinal)

# model.predict([[datetime.datetime.strptime("2025-03-26", "%Y-%m-%d").toordinal()]])